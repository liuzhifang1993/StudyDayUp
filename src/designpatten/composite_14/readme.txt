

   组合模式：
 
 
       一、定义：
    
      1、说明：
      
                            将对象组合成树形结构，以表示 “部分  - 整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性
                        
      2、目的：
         
                           让客户端不再区分操作的是组合对象还是叶子对象，而是以一种统一的方式来操作
      
      3、关键点：
      
                           设计一个抽象的组件类，让他可以代替组合对象和叶子对象
                           
      4、拓展：
      
                           组合模式可以组合出树形结构，  意味着所有使用对象树来描述或者操作的功能，都可以使用组合模式，
                          比如读取XML文件，或者对语句进行语法解析                                    
                           
      5、组合模式递归：
      
                         组合模式的递归是对象递归组合，不是常说的递归算法，通常的递归算法是指“一个方法会调用方法自己”、
 
      6、问题解答：
          
         Component中是否应该实现一个Component集合？
                                     不应该，应该子叶子不需要，浪费空间
         Component为了让客户端不区分叶子和组合对象，把方法都放入Component中，是否显得打杂会？
                                     不是，需要可以实现，不需要不用管，如果调用抛出异常。
 
 
      7、安全性和透明性：
      
                           安全性：
                                       说明：用户使用组合模式，是否是安全的，如果是安全的，那么不会发生误操作可能，能访的方法
                                       实现： 可以把   Component方法提取到组合对象 Composite中
                                                     
                           透明性：
                                       说明：用户使用组合模式，是否需要区分组合对象和叶子对象。如果是透明的，客户端不需要是叶子还是组合对象               
                                       实现：统一继承Component，客户端 直接调用Component
                                       
                           建议多采用 透明性，少采用安全性
 
 
 
       8、父组件引用
       
                            引出的问题：如果要删除某个商品类别，如果这个类别没有子类别，直接删除就行。如果改类别有子类别，那涉及到子类别如何处理呢？           
                  
                  1、直接连带删除      2、上移一层。把被删除的商品的父类别设置为被删除商品子类别的父类别。
 
                            针对第二种情况，处理方式：
                            
                                                  比较容易的方式：在组合对象添加子组件对象的时候，为子组件对象设置父组件引用。                  
       
       9、环形引用：
       
                               如：  A包含B , B包含C, 而C又包含A, 这样就构成了一个环形引用
                                    一般情况下，是不应该出现环形引用的，出现了，意味着出现了错误                            
                                   检验方法：记录每个组件在根节点开始的路径，如果出现环形引用，则某个对象必然出现两次                    
       
                           参考test3 -- 检验环形引用
                           
       10、组合模式优缺点：
       
                                   优点： 统一了叶子对象和组合对象
                                               简化了课后端的调用 ，更容易扩展
                                  
                                   缺点:难以限制组合对象的类型                     
                                                     
       11、本质：
       
                                 统一叶子对象和组合对象

 
       二、例子：
         
        +服装
           +男装
             -衬衣
             -夹克           
           +女装
             -裙子
             -套装 
                  
                    （1）常规思路：以上可以分析出： 
                                                根节点：  没有父节点，可以包含其他节点。比如：服装
               	  树枝节点： 有父节点，可以包含其他节点。比如：男装，女装
                                                叶子节点： 有父节点，没有子节点。  比如：裙子，套装，衬衣，夹克       
                 
                                实际上，以上又可以分析知：容器节点（根节点，树枝节点）、 叶子节点                   
              //容器对象
              public class Composite{
                 private Collection<Composite> cmps = new ArrayList<Composite>();
                 private Collection<Leaf> leas = new ArrayList<Leaf>();
                 
                 public void addLead(Leaf leaf){
                    leas.add(leaf);
                 }
                 public void addComposite(Composite cmp){
                    cmps.add(cmp);
                 }
               
              }         
              //叶子对象
              public class Leaf{
                 private String name;
                 public Leaf(String name){
                    this.name = name;
                 }
              }               
              //使用
              Composite root = new Composite("服装");
              Composite c1 = new Composite("男装");
              Composite c2 = new Composite("女装");
                
              Leaf leaf1 = new Leaf("衬衣");
              Leaf leaf2 = new Leaf("夹克");
              Leaf leaf3 = new Leaf("裙子");
          
              root.addComposite(c1);
              root.addComposite(c2);
              c1.addLeaf(leaf1);
              c2.addLeaf(leaf2);
              c2.addLeaf(leaf3);
       
       
                                总结：以上方式，把组合对象和叶子对象区分处理，这就导致使用的时候也要区分使用。
         
       
                    （2）、使用组合模式： 
       
                                         组合模式引入一个抽象的组件对象，作为组合对象和叶子对象的父对象，这样就把组合对象和叶子对象统一起来了。
                                 操作的时候始终组件对象，而不再区分叶子对象和组合对象了。                    
       
       
       
       
       
       
         
         
         
            