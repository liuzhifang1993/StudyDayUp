
  享元模式：
  
          一、说明：
       
       1、定义：
       
                           运用共享技术有效的支持大量细粒度的对象
       
       2、说明：
       
                          造成内存浪费的主要原因：就是细粒度的对象太多，而且有大量重复的数据。 
                          一个基本的思路：就是缓存这些包含重复数据的对象                  
                          因此：需要分离出被缓存对象实例中，哪些数据是不变并且重复出现的，哪些数据是经常变化的。
                           
                         对于那些被缓存的数据是"不变并且重复的数据" -- 对象的内部状态
                                            那些不被缓存的数据是"变化的数据" -- 对象的外部状态
    
                         故，把内部状态分离出来共享，称之为享元，通过共享享元对象来减少对内存的占用
                                 把外部状态分离出来放在外部，让应用使用的时候进行维护，并在需要的时候传递给享元对象使用                 
    
                        为了控制对内部状态的共享，并且能让外部能够简单的使用共享数据，提供一个工厂来管理享元 -- 享元工厂
    
      3、模式说明：
      
         Flyweight:享元接口，通过这个接口，可以接受并作用于外部状态。
                                                      通过这个接口传入外部的状态，在享元对象的方法处理中可能使用这些外部的数据
         ConcreteFlyweight:具体的享元实现类，必须是可共享的，需要封装Flyweight的内部状态
         UnsharedConcreteFlyweight:非共享的享元实现类，并不是所有的Flyweight实现对象
                                                                                                  都需要共享，非共享的享元实现对象通常是对共享享元对象的组合对象
         FlyweightFactory:享元工厂，用来创建并管理共享的享元对象。并对外提供访问共享享元的接口
         Client: 享元客户端，主要工作是维持一个对Flyweight的引用，计算或者存储相应对象的外部状态
                                                这个可以访问共享和不共享的Flyweight对象
      
      4、 关键点：
      
                                 享元模式重点在于分离变和不变，把一个对象的状态分为内部状态和外部状态。内部状态是不变的，外部状态是可变的。
                         然后通过共享不变的部分，达到减少对象的数量并节约内存的目的。               
                                 在享元对象需要的时候，可以从外部传入外部状态给共享的对象。共享对象在处理功能的时候，会使用自己内部状态和这些外部状态
       
      5、共享和不共享 -- 跟组合模式合用
       
                            在享元模式中，享元对象有共享和不共享之分，通常出现和组合模式合用的情况，通常共享的是叶子对象，一般不共享的部分是由
                            共享部分组合而成，由于所有粒度的叶子对象已经缓存了，那么缓存组合对象也没有意义。                
         
      6、享元模式的内部状态和外部状态  
                      
                           内部状态：通常指的是包含享元对象内部的、对象本身的状态。是独立于使用享元场景的信息，一般创建后就不再变化
                                                                 因此可以共享 。                
       
                           外部状态：指的是对象之外的状态，取决于享元的场景，会跟进场景而变化。
                    
                           也就是说享元模式真正缓存和共享的数据是享元的内部状态，而外部状态不应该被共享缓存                   
       
      7、实例池
      
                          在享元模式中，为了创建和管理共享的享元部分，引入了享元工厂。
                          享元工厂中一般包含有享元对象的实例池，享元对象就是缓存在这个实例池中。
        
         
      8、不需要共享的享元实现       
       
                          一般享元就是要共享的对象，但是有一些不需要共享的享元实现，这种情况多出现在组合结构,对于使用已经缓存的享元
                       组合的对象，就没有必要缓存了。
                     
                        实例：比如要给某人分配  "薪资数据" 这个安全实体 "修改"  权限，那么一定会把 "薪资数据" 查看权限分配给这个人。           
                                   按照上面，那么需要分配两个对象。所以为了方便，就打包成一个对象：
         
                        这样"操作薪资数据" 相当于一个不需要共享的答案，他实际由 享元 "薪资数据" 的 "查看权限" 和 享元  "薪资数据" 的 "修改权限"
                        两个享元构成 ，因此 "操作薪资数据"本身不需要共享。                                                              
                              
                       这种组合对象一般不会进行权限验证，如果需要验证的时候，也是一个个进行判断
         
          (具体见test2)               
             
      9、 对享元对象的管理
      
                               虽然享元模式对共享的享元对象实例的管理要求没有实例池对实例管理的要求那么高，
                               但是还是有很多自身的特点： 引用计数（享元工厂记录每个享元的使用次数）、垃圾清除（就是不再需要的缓存对象）              
       
                                    引用计数思路：在享元工厂中定义一个map,他的key值与享元对象的key,value就是引用的次数
                                                               这样当每次使用的时候，引用次数就加1             
                                   垃圾回收思路：定义一个缓存对象的配置对象，这个对象描述了缓存的开始时间和最长不被使用的时间的时间
                                                              判断是否是垃圾对象：当前时间 - 缓存的开始时间 》最长不被使用时间              
                                                              也就是说每次使用对象，就将缓存开始时间更新为当前时间
                                                              当判断是垃圾后，就进行回收                                                                               
      
           (具体见test3)
   
      10、享元模式优缺点：
      
                              优点：减少对象数量，节省内存空间
                              缺点：维护共享对象需要额外的开销         
            
      11、享元模式：
      
                             本质是：分离和共享
             
      12、何时选择享元模式：
       
                           如果一个应用大量使用了细粒度对象，可以使用享元模式减少对象数量
                           如果由于使用大量对象，造成很大内存开销，可以使用享元模式减少对象数量，并节省内存开销
                           如果对象的大部分状态可以转变为外部状态，比如通过计算得到，或是从外部传入，
                                         可以使用享元模式分类内部状态和外部状态
                           如果不考虑对象外部状态，可以用相对较少的共享对象来取代组合对象，可以使用享元模式来共享对象，
                                      然后组合对象来使用这些共享对象   
                          
           二、示例  
  
       1、权限说明：
      
                        （1） 一个系统加入权限控制，是基本功能。对于应用系统，一般先登录系统才能使用系统的功能
                                     登录后，用户的每次操作，都要经过权限系统的控制。
                                
                         （2） 几乎所有的授权系统都分为两部分：授权部分，验证部分 。    
                               
                                      安全实体：就是被权限系统检测的对象，比如工资数据
                                      权限：就是需要被校验的权限对象，比如查看、修改等。
                                      授权：是指对某些安全实体的某些权限分配给某些人的过程                                                   
                                      验证：是指判断某个人员对某些安全实体是否拥有某些权限的过程                                   
                                
                                     也就是说：授权是权限的分配过程，而验证是权限的匹配过程  
                                     在目前的系统中，授权是往数据库添加数据过程，而匹配是从数据库获取数据的过程       
                                               
                        （3） 权限的两个特征：                    
         
                                 继承性：如果多个安全实体存在包含关系，而某个安全实体没有相应的权限控制，那么它也会继承包含他的安全实体的权限
                                                比如：进入大厦需要进入大厦的权限，那么如果能够进入大厦某个房间，那么也就有能进入大厦的权限
          
                               最近匹配原则：如果多个安全实体存在包含关系，而某个安全实体没有相应权限限制，那么会向上寻找并匹配相应的权限控制
                                                         直到找到一个离这个安全实体最近的拥有相应权限控制的安全实体为止。如果整个层次都寻找完了，仍然没有匹配
                                                         相应权限限制，则说明所以人对这个安全实体都拥有相应权限              
                                            比如：  一栋大楼坐落在某个机关大院，就变成了要进入大厦的某个房间，就需要大厦的权限，要进入大厦，就需要进入
                                                        机关大院的权限 。所谓最近匹配原则就是，如果某个房间没有门，意味着进入这个房间没有权限控制，那么会继续
                                                        向上匹配，看大楼有没有权限控制，如果有，则使用这个权限，如果没有则继续向上寻找，如果最后大院也没有权限控制，
                                                        则变成所有人都可以进入这个房间         
                                                           
                                                                      
    
       2、 实例说明：
                                 
                                      普通员工都有查看本部门人员列表的权限，但是没有查看薪资的权限；部门经理处理可以查看人员列表的权限
                                      也有查看人员薪资的权限 。
                                
                                      假设授权已经完成，授权数据记录在数据库，如下：
           
                                               张三    对    人员列表            拥有    查看的权限                  
                                               李四    对    人员列表            拥有    查看的权限    
                                               李四    对    薪资数据            拥有    查看的权限                     
                                               李四    对    薪资数据            拥有    修改的权限                     
                                  
                                  
                                     常规思路：当每个人员登录时候，就获取该人员能操作的权限，并存储在内存中，这样每次操作从内存中获取 ，加快速度。                                                       
                                                        具体见：example                  
                                  
                                     示例存在的问题：
           
                                             （1）缓存时间长度的问题：缓存数据存放多久的问题，web应用一般放在session中，session超时时就会清楚，
                                                                                            非web应用需要自己处理，但是存放多久是个问题   ？   
                                             （2）缓存数据和真实数据同步问题：如果缓存期间，数据库权限变动了，怎么处理？                                             
                                             （3）缓存多线程并发控制 ：  对于缓存数据，有些向缓存取值，有些从里面读值，在一个多线程环境，怎么合理对缓存进行
                                                                                                 控制？                                       
                                               缓存设计相关，暂不关心                    
                           
                                     另外存在的问题：
             
                                           上面每一条记录，就存在一个对象，如果记录特别多，那对象也很多，明显不合理                     
                                  
                                     解决方案：享元模式       -- 见test1     
                       
                       
                       
                       
                       
                       
                       
                       
                                  
                                                   