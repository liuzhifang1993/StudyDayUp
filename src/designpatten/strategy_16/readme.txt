
 
    策略模式：
    
          一、说明：
   
      1、定义：
      
                         定义一系列的算法，把他们一个个封装起来，并且可以使他们互相替换。本模式使得算法可独立于使用它的客户而变化
                               （1）、先是客户端来选中并创建具体的策略对象 
                               （2）、然后客户端创建上下文  ，上下文持有策略对象
                               （3）、接下来客户端调用上下文的方法执行功能                                 
    
      2、策略模式功能
      
                         把具体的算法从具体业务独立出来，把他们实现单独的算法类，从而形成一系列的算法，并让这些算法可以互相替换
                         
      3、策略模式重心
      
                        策略模式重心不是如何实现算法，而是如何组织算法，调用算法，从而让程序更加灵活，具有良好的维护性和可扩展性                    
                         
      4、算法的平等性：
      
                        策略模式的特点在于各个策略算法的平等性。可以互相替换
      
      5、运行时策略的唯一性：
         
                       策略模式每个时刻只能使用一个具体的策略实现对象
    
      6、Context和Strategy关系
      
                        在策略模式重，通常是上下文使用具体的策略实现对象，反过来，策略实现对象也可以从下文获取数据、
                        因此两者是紧密相连的。               
                        
      7、容错恢复机制：
      
                        容错恢复机制很常见，比如程序运行时，发生错误不崩溃，而是容忍程序出现的错，安装备用方案运行。
                        比如： 一个系统中，所有对系统的操作都要有日志记录，而且这个日志还需要管理界面，通常情况会把日志存放
                                    在数据库中，方案日后管理，但是可能会发生错误，比如连不上数据库，这个时候可以先把日志存放在文件
                                    合适的时候，再把日志存放在数据库                                                      
       
                         这时可以采用策略模式：把日志记录在文件 和 记录在数据库两种策略
                     见示例：test3
                   
      8、策略模式结合模板方法模式           
        
                       经常会发现一种情况，"一系列算法的实现步骤是一样的，只是某些步骤不一样"  ，这个时候可以结合模板方法       
                       比如，上面记录日志的例子，现在需要给所有的日志加上日志时间，则步骤就变成：       
              1、为日志消息添加日志时间
              2、 具体记录日志         
                      见示例：test4                    
        
      9、策略模式分析：
      
                           适用场景：策略模式中的一系列算法地位是平等的，可以相互替换
                                              出现许多相关的类，但是仅仅是行为上的差别
                                              一个算法，有不同的实现
                                              需要封装算法，避免暴露算法的数据结构            
                           
                                缺点：客户端需要选择使用哪一类算法，这就导致需要了解各个策略模式的不同及其内部实现
                                           每个算法都有个实现类，导致对象数目增加     
      10、本质：
      
                            分离算法，选择实现                                     
                                                       
     
          二、示例1：
   
      1、例子：
      
                         销售部门对客户报价，针对不同的客户要报不同的价格，比如：
           1、 对普通客户或者新客户报全价
           2、对老客户报的价格，统一折扣5%
           3、对大客户报的价格，统一折扣10%
                                  
                         但是以上的策略，随时有可能改变，比如：
           1、公司周年庆的时候，所以客户额外增加3%的折扣
           2、 换季促销的时候，普通客户额外增加2%折扣，老客户额外增加3%折扣，大客户额外增加5%折扣    
          
                          而过了这些时候，价格又会回到正常价格体系                        
                          那么针对以上问题，改如何设计呢？      --- 答案:使用策略设计模式                 
          
          
      2、解析：
      
                             仔细分析上面问题，先抽象一下，各种计算报价的方式好比具体的算法，而使用这些计算方式的程序相当于使用算法的客户
                         针对实现类 : strategy_16.test1.normal.Price 存在的问题： 不便于维护和后期扩展
          
                         根本原因在于：算法和使用算法耦合在一起  
                        
                        
      3、解决方式：
      
                               应该把所有的算法独立出来，每个计算方式做成一个单独的算法类，并且为这些算法定义一个公共的接口，这些算法实现同一接口
                          的不同实现，这些算法地位平等，可以互相替换，如果需要拓展，增加一个新的算法类即可。并且可以跟据客户端动态切换。
      
      
       三、示例2：
       
       1、工资支付实现：
       
                                    工资支付问题，很多企业工资支付很灵活，支付方式也很多种。比如：人民币支付，美元现金支付，
                            银行卡转账到工资账户，银行卡转账到工资卡
                             
                                    随着公司的发展，不断出现新的支付方式，而且不同的员工可以选择不同的支付方式                
        
       3、分析：
       
                                   要实现这样的功能，策略模式是一个很好的选择。    
                            但是不同的策略模式需要的数据不一样。比如，现在支付不需要银行卡账号，而银行卡转账需要账号 
       
                                   解决方式，就是把上下文作为参数传递给策略对象  
   
                                具体见test2
   
      
      
      
      
      
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
           
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
                               
                               
                                
       
       