

   解释器模式：
   
   
       一、模式说明
     
       1、定义：
      
                             给定一个语言，定义一套语法规则，也称为文法，并定义一个解释器，这个解释器使用改表示来解释语言中的句子。
      
       2、使用解释器模式解决问题的思路：
       
                              思路：
                                           就到要把解析部分的代码写成公共的，而且还是通用的，能够满足各种xml取值的需要，比如获取单个元素的值，
                                           或者多个相同，元素的值等等，
                
                             两个概念：解析器和解释器
                                                解析器：指的是客户端调用要求的表达式，经过解析，形成一个抽象语法树的程序，不是指xml的解析器         
                                                解释器：指的是解释抽象语法树，并执行每一个节点对应的功能的程序，
       
                             步骤： 1、需要设计一个简单的表达式语言，在客户端调用解析程序的时候，传入用这个表达式语言描述的一个表达式，然后
                                                通过解析器的解析，形成一个抽象的语言树。
               2、解析完成后，自动调用解析器来解释抽象语法树，并执行每个节点对应的功能 ，从而完成通用的xml解析
               3、每当xml结构发生改变时，传入不同的表达式即可。                                     
     
       3、模式结构说明：
       
           AbstractExpression: 定义解释器的接口，约定解释器的解释操作
           TerminalExpression:终结符解释器，用来实现语法规则中和终结符相关的操作，不再包含其他的解释器
                                                                                   如果用组合模式来构建抽象语法树的话，就相当于组合模式中的叶子对象，可以有多种终结符解释器
           NonterminalExpression:非终结符解释器，用来实现语法规则中非终结符相关的操作，通常一个解释器对应一个语法规则
                                                                                     如果用组合模式来构建抽象语法树的话，就相当于组合模式中的叶子对象，可以有多种非终结符解释器                                                                        
           Context:上下文，通常包含各个解释器需要的数据或是公共的功能
           Client:客户端，指的是使用解释器的客户端，通常按照语言的语法做的表达式转成成使用解释器对象描述的抽象语法树
                                                   然后调用解释操作
    
  
       4、使用解释器模式解决提到的问题：
       
                             （1）、为表达式创建简单的文法
                             
                                                为了通用，用root表示根元素，a、b、c、d来表示元素，一个简单的xml如下                 
                 <?xml version="1.0" encoding="utf-8">
                 <root id="rootOD">
                   <a>
                     <b>
                        <c name="testC">123456</c>
                        <d id="1">d1</d>
                        <d id="2">d1</d>
                        <d id="3">d1</d>
                        <d id="4">d1</d>
                     </b>
                   </a>
                 </root>
             
                                       约定表示式的文法如下：      
                  1、获取单个元素的值：
                                                              说明： 从跟元素开始，一直到想要获取值的元素，元素中间用"/"分隔，跟元素不加/
                                                              例子：比如表达式"root/a/b/c" 表示：根元素下、a元素下、b元素下的c元素的值          
                    
                  2、获取单个元素的属性的值：
                                                               说明：要获取的属性一定是表达式的最后一个元素的数据，在最后一个元素后面加"."，然后加上属性的名称
                                                               例子：比如表达式"root/a/b/c.name" 表示：根元素下、a元素下、b元素下的c元素的name属性的值 
   
                  3、获取相同元素名称的值：
                                                               说明：当然获取的值是多个，要获取元素一定是表达式的最后一个元素，在最后一个元素加"$"
                                                               例子：比如表达式  "root/a/b/d$" 表示：根元素下、a元素下、b元素下的多个d元素的值的集合
  
                  4、 获取相同元素名称的属性的值，当然也是多个： 
                                                               说明：要获取属性值的元素一定是表达式的最后一个元素，在最后一个元素的后面也添加"$",然后在后面添加"."，
                                                                           然后再加上属性的名称, 在属性名称后面加上"$"           
                                                               例子：比如表达式"root/a/b/d$.id$": 示：根元素下、a元素下、b元素下的多个d元素的id属性的值的集合
                                                               
                            （2）、抽象的语法树 
                            
                                             对于树形结构，明显可以使用组合模式来构建。解释器把需要解释的对象分为两大类，
                                                     一类是节点元素，就是可以包含其他元素的组合元素比如非终结元素对应组合模式的Composite；
                                                     另一类是终结符元素，相当于组合模式的叶子对象                        
                
                                            解释整个抽象语法树的过程，就是执行相应功能的过程
                                                     非终结符：root
                                                               非终结符：a                                  
                                                                      非终结符：b                     
                                                                           非终结符：c               
                                                                                    属性终结符：name                                    
                                                                           元素终结符：d    
          
        5、认识解释器模式：
       
                                （1）、解释器模式的功能
                                                   一般一个解释器处理一条语法规则，一条语法规则可以有多个解释和处理
                                （2）、上下文共用性：        
                                                  上下文会传递到所有的解释器中，因此可以在上下文中存储和访问解释器的状态  。
                                                  比如前面的解释器可以存储一些数据在上下文中，后面的解释器可以获取到这些值                                                                                   
                                                 上下文还可以给解释器提供公共的功能，类似于对象组合
                                                 
       6、谁来构建抽象语法
       
                                    从例子来看，自己在客户端手动构建抽象语法树，是很麻烦的。但是在解释器 模式中并没有涉及到这部分功能。只是对负责构建好的抽象语法树进行解析
                                    后面例子会处理这一点         
                                    
                                   一条语法规则，可以对应多个解释器底下，也就是桌同一个表达式可以构成不同的抽象语法树，这也造成构建抽象语法树很困难，工作量也大                                                                                          
  
       7、谁负责解释操作 -- 解释器
            
                                只要定义好了抽象语法树，则肯定是解释器来负责解释执行 。虽然有不同的语法规则，但是解释器不负责选择哪一个解释器对象执行语法规则
                                选择解释器的功能在构建抽象语法树的时候就创建好了                       
  
  
       8、读取多个元素或属性的值
       
                                      读取多个值和读取单个值实现思路大致一样，只是取值的时候需要循环这整个NodeList，依次取值，而不是只取出第一个来，当然由于语法发生了变动
                               所以对应的解释器也需发生变化。
                                     首先有一个表示多个元素作为终结符的语法 ，比如"root/a/b/d$" 中的"d$"                                  
                                     其次有一个表示多个元素的属性作为终结符的语法，比如"root/a/b/d$.id$"  中的"id$"
                                     最后还有一个表示多个元素，但不是终结符的语法，比如"root/a/b/d$.id$"  中的"d$"
                              相对于之前的变化：
                                     把原来用来记录上一次操作的元素，变成记录上一次操作的多个元素的集合                
                                     根据父元素和当前元素名称获取当前元素的方法，变成根据父元素和当前元素的名称来获取多个元素                 
                                     重新初始化上下文的方法里面，初始化就是记录上一次操作的多个元素的这个集合                 
   
       9、解析器
        
                           前面只要构建了抽象语法树，解析器就能正确的解释并执行它，那如何得到抽象语法树呢？前面都是人工组装好语法树
                           那实际开发中也是非常麻烦的，这个时候就需要解析器了
       
                          作用：把符合前面定义的语法表达式转换为前面实现的解释器的抽象语法树
            
       10、解析器实现思路：
       
           1、把客户端传递来的表达式进行分解，分解成一个个元素，并用一个对应的模型来封装这个元素的信息
           2、根据每个元素的信息，转换成相对应的解析器对象
           3、按照先后顺序，把这些解析器对象组合起来，就得到抽象语法树
                                   实现见(test3)
       
       11、解释器模式的优缺点
       
                                 优点：
                                      易于实现语法：一条语法规则用一个解释器对象解释执行。
                                      易于扩展新的语法 ：正是由于一个解释器对象负责一条语法规则方式，是的扩展新的语法非常容易
                                 缺点：
                                     不适合特别复杂的语法 ，语法特别复杂，解释器需要的抽象语法树的工作就非常艰巨。                                 
        
   
  
       二、示例说明   
   
       1、考虑一个这样的实际应用：维护系统自定义的配置文件。
                                 配置文件由开发人员根据需要自定义，系统运行时会跟据配置的数据进行相应的功能处理
                                 配置文件如下：
              <?xml version="1.0" encoding="utf-8">                   
              <root>
                <jdbc>
                  <driver-class>驱动类名 </driver-class>
                  <url>连接数据库的url</url>
                  <user>连接数据库用户名</user>
                  <password>连接数据库的密码</password>
                </jdbc>
                <application-xml>缺省读取的Spring配置的文件名</application-xml>             
              </root> 
              
                            不用模式的解决方案：见example
                            
       2、 存在的问题：明显配置文件会变动，各个根节点也会变，那代码也会随之变动。 
       3、解决方案：使用解释器模式来解决问题                                         
                                             具体见(test1)            
                                             
                                                
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         
                                                              