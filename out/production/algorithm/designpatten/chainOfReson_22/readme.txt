

  责任链模式

    一、说明
    
     1、定义：
          
                     使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。
                     将这些对象连城一条链，并沿着这条链传递该请求，知道有一个对象处理他为止
  
     2、应用责任链模式解决问题的思路
     
                            分析上面的应用场景，当客户端提出一个聚餐费用的申请，后续处理这个申请对象的项目经理、 部门经理和总经理自然形成了一个链 ，
                     这个申请在这条链中传递，直到有领导处理为止。
                            而责任链模式很好的体现了上述思路：
                                     首先责任链模式会定义一个所有处理请求对象都要继承的抽象类，这样有利于随时切换新的实现；
                                     其次每个请求只实现业务流程中的一f步业务处理，这样使其变得更加简单；
                                     最后责任链会动态的组合这些请求的对象。                           
                                                                    
                             这样如果流程发生了变化，只需要重新组合就行。如果某个处理的业务功能发生了变化，一个方案是修改该处理对应的类；另一个是
                        直接提供一个新的实现，然后在组合的方式用新的替换掉旧的实现就行了。                    
  
     3、责任链模式的功能：
     
                        责任链模式主要处理：客户端发出一个请求，有多个对象都有机会来处理这个请求，但是客户端不知道究竟谁会处理他的请求，这样
                        可以动态的切换和组合接受者了。
                        
     4、隐式接受者
     
                      对于客户端发出的请求，并不知道接受者是谁，一般情况下，总有一个对象来处理，因此称为隐私接受者
  
     5、如何构建责任链
        
                    按照实现的地方来说：  
                           可以在客户端提交请求前组合责任链，也就是在使用的时候动态组合链，称为外部链；
                           也可以在Handler里面实现链的组合  
                           还可以在各个职责对象中，由各个职责对象自行决定后续的处理对象 ，这就要求每个职责对象除了进行业务处理外，还必须了解整个业务流程          
                    按照构建链的数据来源，也就决定了按照什么顺序来组合链的数据： 
                            一种在程序中动态组合
                           也可以通过外部，比如数据库来获取组合的数据，这种属于数据库驱动方式
                           还有一种方式就是通过配置文件传递进来，也可以是流程的配置文件  
                                         
     6、谁来处理
  
                      责任链有那么多处理对象，由谁来处理，是在运行期动态决定的
  
  
     7、处理多种请求
     
                     前面只处理一种请求，现在有个需求就是再增加一种费用申请功能，假设流程还是一样的，也是组合一个责任链：经理 - 部门经理  - 总经理
                     那么如何处理呢？常规的思路就是在之前责任对象接口再加一个方法如下：
            public abstract class Handler{
            
               protocted Handler successor = null;
               
               public void setSuccessor(Handler successor){
                  this.successor = successor;
               }
               
               //处理聚餐费用的申请
               public abstract String handleFeeRequest(String );
               
               //处理预支差旅费用的申请
               public abstract boolean handlePreFeeRequest();
               
            }          
                                 
                    那这样职责接口发生了改变，则对应处理类也要改变 ，这样非常不灵活   
                    实际分析可知，变化的东西有如下几种： 
             1、不同的业务需要传递的业务数据不同
             2、不同业务请求的方法不同
             3、不同职责对象处理这些不同的业务请求的业务逻辑不同
         
                   故针对上述变化，可以有一种简单方式：
                                   首先定义一套通用的调用框架。用一个通用的请求对象来封装请求传递的参数   ；
                                   然后定义一个通用的调用方法，这个方法不区分具体的业务，所有业务都是这一个方法，业务的区分通过在通用请求对象中增加一个业务的标记
                                   到了职责对象中，愿意处理就和原来方式一致，不愿意处理这传递给下一个处理对象就可以了                      
                                                                                
    8、功能链
    
                     在实际开发中，会遇到这样一种情况：
                                     在标准的责任链中，一个请求在责任链中传递，只有一个对象处理这个请求，但是有时候可能是
                                      一个对象只负责处理某一方面的处理，处理完成会继续往下传递，而不是停止。这种责任链称为功能链
    
                        场景：比如在进行业务处理之前，需要进行权限检查、通用数据校验、数据逻辑校验等处理，然后才开始真正的业务逻辑  
                                   这样可以把这些功能分散到功能链中，这样会更加灵活（也可以用装饰者模式，但是责任链更加灵活）           
                                    装饰模式各个装饰
                                    
                       具体见test3  
                       
    9、职责链模式的优缺点    
   
                   优点：
    
                        将请求者和接受者松散耦合 ：
                                  在责任链模式中，请求者并不知道接受者是谁，也不知道具体如何请求。请求者只负责向职责链发出请求就可以了。
                                  每个责任链对象不用管请求者或者其他的职责对象
                                                                         
                        动态组合职责： 
                                 职责链模式会把功能处理分散到单独的职责对象中，然后再使用的时候，可以动态组合职责形成职责链，
                                从而可以灵活的实现和改变对象的职责                                
                    
                 缺点：
                 
                       会产生很多的细粒度对象：职责链会把功能处理分散到单独的职责对象中，也就是每个职责对象只处理一个方面的功能，
                                                                    要把整个业务处理完，需要很多职责对象的组合，这样会产生大量的细粒度职责对象
          
                      不一定能被处理：职责链对象只处理自己的那部分，因此可能出现某个请求，整个链传完了，都没有职责对象处理他。这就需要
                                                    在使用职责链模式的时候，需要提供默认的处理，并且注意构建链的有效性                                                            
     
     
     10、职责链模式的本质：
      
                       分离职责，动态组合
      
      
     11、何时使用职责链模式：
      
                        如果有多个对象处理同一个请求，但是具体由哪个对象处理请求，是运行时动态确定的，这时可以使用该模式、                                     
                        如果想在不明确接受者的情况下，向多个对象的其中一个提交请求的话，可以使用该模式   。（可以实现接受者和请求者之间松散耦合）
                        如果想要动态指定处理一个请求的对象集合，可以使用该模式 -- 职责链能够动态的构建，也就是动态的决定哪些职责对象来参与到处理请求之中。                                           

     二、实例
     
              （1）、申请聚餐费用：
              
                         一般流程是：申请人填写申请单，然后交给领导审查，如果批准了，则领导通知申请人批准通过，然后申请人去财务领取费用；
                                             如果没有批准，则领导也会通知申请人审批没有通过，则此事作罢      
                      
                           细节：不同级别的领导，对于审批的额度不一样的，比如，项目经理只能审批500元以内；
                                       部门经理只能审批1000以内 ；而总经理可以审核任意额度的申请         
                                       
                                  也就是当某人提出聚餐费用，该请求会由项目经理、部门经理、总经理之中的某一个领导进行相应的处理。但是提出申请
                           并不知道最终会由谁来处理他的请求。   
                                    一般申请人会把请求交给项目经理，可能最后是总经理来处理他的请求 。但申请人并不知道最后是总经理处理他的请求                 
                                                                                    
                          常规实现见：example示例       
                          
               （2）、存在的问题     
                            
           1、 聚餐费用申请的流程可能会变化。
                                        现在是：先交给项目经理处理，看是否合适，如果不合适会交给部门经理，如果部门经理不合适则交给总经理 
                                       以后可能是：直接交给部门经理。如果部门经理不合适则交给总经理        
                                                 
                                       故要求处理逻辑步骤是灵活的                                     
               
           2、处理各个环节的业务也可能变化：
                                         因为除了流程变化，可能会导致某些具体步骤发生变化，
                                                 比如原来：部门经理审批 聚餐费用只是是否批准
                                                 现在：部门经理可能在审批聚餐费用的同时还会核算部门实时成本                                                  
       
              （3）、常见解决思路：                        
                              
             1、生成一个子类，覆盖父类的requestToProjectManger方法，然后在里面实现新的逻辑
             2、修改出来申请方法的源代码
             
                                   但是都不是好的解决方法 ， 将上面流程抽象就是：                               
                                            客户端发出一个请求，会有很多对象来处理这个请求，而且不同对象的处理逻辑不一样。对客户端而言，谁处理都行。
                                            而且上述处理中，还希望处理流程可以灵活变动，而处理请求的对象能够方便的修改或者被替换掉，以适应新的业务功能需要                                                  
                          
                                   这个时候责任链模式出来了。    
                                 
                                        
                              
                              
                              
                                                                                        